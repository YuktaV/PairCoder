# Model Context Protocol (MCP) Integration Guide

This document explains how to effectively use PairCoder output with Claude and how to integrate the MCP into your workflow for optimal results.

## Setting the Context

When working with Claude on a project, you can use PairCoder to provide the right context at the right level of detail. Here's how to use it effectively:

### 1. Initial Project Context

When starting a new conversation with Claude, begin with the high-level project context:

```
I'm working on a project with the following structure, generated by PairCoder:

<paste output from `pc export --level=high`>

Let's discuss [specific topic or issue].
```

### 2. Module-Specific Focus

When diving into a specific area of your codebase:

```
I'd like to focus on the [module name] module of my project:

<paste output from `pc focus module-name`>

I need help with [specific task or problem].
```

### 3. Problem Description

For bug fixing or implementation help:

```
I'm encountering an issue in my [module name] module:

<paste output from `pc prompt issue "Brief description"`>

Here are the relevant code sections:

<paste output from `pc export module-name --focus="specific file or function"`>
```

## Context Window Management

To efficiently use Claude's context window:

### Progressive Detail

Start with high-level context and progressively add detail only when needed:

1. Begin with high-level summaries (`--level=high`)
2. Add medium detail for relevant modules (`--level=medium`)
3. Only use low-level detail for specific components (`--level=low`)

### Context Refreshing

Periodically refresh context when the conversation gets too long:

```
Let's refresh our context with the current state of the [module name] module:

<paste output from `pc export module-name --update`>
```

### Version References

Reference specific project versions for clarity:

```
I'm working on implementing feature X. Here's the project state before I began:

<paste output from `pc version show v1-before-feature-x`>

And here's what I've changed so far:

<paste output from `pc diff --since=v1-before-feature-x`>
```

## Claude Instructions

To get the best results from Claude, include these instructions when setting context:

```
When providing assistance, please:
1. Consider the module boundaries and dependencies shown above
2. Respect the project's existing patterns and conventions
3. Focus specifically on the [module or file] I've highlighted
4. Provide solutions that integrate well with the rest of the codebase

If you need more context on any specific part, please let me know and I can provide more detailed information on that area.
```

## Context Templates

PairCoder includes several context templates for common scenarios:

### Feature Development Template

```
<paste output from `pc prompt feature "Feature description"`>
```

### Code Review Template

```
<paste output from `pc prompt review file-path`>
```

### Debugging Template

```
<paste output from `pc prompt debug "Error description"`>
```

### Architecture Discussion Template

```
<paste output from `pc prompt architecture "Design question"`>
```

## Integration Patterns

### Session Initialization

At the start of each Claude session:

1. `pc focus clear` - Reset any previous focus
2. `pc update` - Ensure context is current
3. `pc export --level=high` - Get high-level project context

### Context Switching

When switching between modules:

1. `pc focus new-module` - Set focus to new module
2. `pc export new-module` - Generate focused context

### Session Continuation

When continuing a previous conversation:

1. `pc journal show` - Review previous decisions
2. `pc export --recent` - Include only recent changes

## Advanced Integration

### Custom Templates

Create custom prompt templates for your specific needs:

```bash
pc template create my-template "My custom template with {{variable}} placeholders"
```

Then use it with Claude:

```
<paste output from `pc prompt my-template "Custom data"`>
```

### Context Filtering

Filter context to focus on specific aspects:

```bash
pc export auth --include="authentication,security" --exclude="registration"
```

### Git Workflow Integration

Link PairCoder versions to your Git workflow:

```bash
# Create version at current commit
pc version save feature-complete

# After code review and changes
git commit -am "Address review feedback"

# Update PairCoder context and create new version
pc update
pc version save feature-revised

# Generate diff for documentation
pc diff --from=feature-complete --to=feature-revised
```

## Best Practices

1. **Update Regularly**: Run `pc update` after significant code changes
2. **Version Milestones**: Create versions at meaningful development points
3. **Module Boundaries**: Keep module definitions aligned with logical code boundaries
4. **Token Efficiency**: Use the appropriate detail level for the task at hand
5. **Context Relevance**: Only include context relevant to the current discussion
6. **Documentation**: Use the journal to track key decisions and insights
7. **Progressive Disclosure**: Start with minimal context and add detail as needed

## Troubleshooting

### Claude Seems Confused About Project Structure

```bash
# Regenerate context with higher detail
pc export --level=medium --focus="area of confusion"
```

### Context Window Limitations

```bash
# Optimize token usage
pc export --optimize --tokens=3000
```

### Module Boundaries Need Adjustment

```bash
# Redefine module boundaries
pc module remove old-module
pc module add new-module path/to/new-module
pc generate
```

### Changes Not Reflected in Context

```bash
# Force complete rescan and regeneration
pc scan --update
pc generate --force
```

## Continuous Improvement

The MCP approach works best with regular refinement:

1. Review and update module boundaries as the project evolves
2. Refine exclusion patterns to ignore irrelevant files
3. Create custom templates for recurring tasks
4. Update your Claude prompting strategy based on results

By following this integration guide, you'll maximize the effectiveness of both PairCoder and Claude, creating a more efficient and productive development workflow.
